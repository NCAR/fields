# coordinates
x<- ozone2$lon.lat
# y is a vector of ozone measurements at day 16. Note some missing values.
y<- ozone2$y[16,]
# artifically reduce size of data for a quick example to pass CRAN ...
x<- x[1:75,]
y<- y[1:75]
# lots of default choices  made here -- see gridN to increase
# the number of points in grid searches for MLEs
# without specifying  lambda or aRange both are found in a robust
# way uses grid searches
# profiling over lambda and aRange  is not reuqired but completes the full
# example.  Omit this for a faster computation.
obj<- spatialProcess( x, y, profileLambda=TRUE, profileARange=TRUE)
# summary of model
summary( obj)
set.panel(2,2)
plot(obj)
plot( obj, which=1)
plot( obj, which=2)
plot( obj, which=3)
plot( obj, which=4)
plot.spatialProcess(which=4)
plot.spatialProcess(obj, which=4)
source('~/Dropbox/Home/Repositories/fields/fields/R/plot.spatialProcess.R', echo=TRUE)
plot.spatialProcess(obj, which=4)
out<- obj
out$summary["tau"]
obj$summary
data( ozone2)
y<- ozone2$y[16,]
good<- !is.na( y)
y<-y[good]
x<- ozone2$lon.lat[good,]
# nearly interpolate using defaults (Exponential covariance range = 2.0)
# see also mKrigMLEGrid to choose lambda by maxmimum likelihood
out<- mKrig( x,y, aRange = 2.0, lambda=.01)
out$summary
source('~/Dropbox/Home/Repositories/fields/fields/R/mKrig.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/fields/R/mKrig.R', echo=TRUE)
data( ozone2)
y<- ozone2$y[16,]
good<- !is.na( y)
y<-y[good]
x<- ozone2$lon.lat[good,]
# nearly interpolate using defaults (Exponential covariance range = 2.0)
# see also mKrigMLEGrid to choose lambda by maxmimum likelihood
out<- mKrig( x,y, aRange = 2.0, lambda=.01)
out$summary
help( mKrigMLE)
library( fields)
help( mKrigMLE)
help( mKrigMLE)
help( mKrigMLEGrid)
help( mKrigMLEGrid)
help( mKrig)
library( fields)
help( "mKrigMLEGrid")
data(ozone2)
s<- ozone2$lon.lat
z<- ozone2$y[16,]
gridList<- list( aRange = seq( .4,1.0,length.out=20),
lambda = 10**seq( -1.5,0,length.out=20)
)
par.grid<- make.surface.grid( gridList)
out<- mKrigMLEGrid( s,z, par.grid=par.grid,
cov.args= list(smoothness=1.0,
Covariance="Matern" )
)
outP<- as.surface( par.grid, out$summary[,"lnProfileLike.FULL"])
image.plot( outP$x, log10(outP$y),outP$z,
xlab="aRange", ylab="log10 lambda")
data(ozone2)
s<- ozone2$lon.lat
z<- ozone2$y[16,]
gridList<- list( aRange = seq( .4,1.0,length.out=20),
lambda = 10**seq( -1.5,0,length.out=20)
)
par.grid<- make.surface.grid( gridList)
out<- mKrigMLEGrid( s,z, par.grid=par.grid,
cov.args= list(smoothness=1.0,
Covariance="Matern" )
)
outP<- as.surface( par.grid, out$summary[,"lnProfileLike.FULL"])
image.plot( outP$x, log10(outP$y),outP$z,
xlab="aRange", ylab="log10 lambda")
dev.off()
image.plot( outP$x, log10(outP$y),outP$z,
xlab="aRange", ylab="log10 lambda")
N<- 50
set.seed(123)
x<- matrix(runif(2*N), N,2)
aRange<- .2
Sigma<-  Matern( rdist(x,x)/aRange , smoothness=1.0)
Sigma.5<- chol( Sigma)
tau<- .1
#  250 independent spatial data sets but a common covariance function
#    -- there is little overhead in
#        MLE across independent realizations and a good test of code validity.
M<-250
F.true<- t( Sigma.5) %*% matrix( rnorm(N*M), N,M)
Y<-  F.true +  tau* matrix( rnorm(N*M), N,M)
# find MLE for lambda with grid of ranges
# and smoothness fixed in Matern
par.grid<- list( aRange= seq( .1,.35,,8))
obj1b<- mKrigMLEGrid( x,Y,
cov.args = list(Covariance="Matern", smoothness=1.0),
par.grid = par.grid
)
obj1b$summary # take a look
# profile over aRange
plot( par.grid$aRange, obj1b$summary[,"lnProfileLike.FULL"],
type="b", log="x")
N<- 50
set.seed(123)
x<- matrix(runif(2*N), N,2)
aRange<- .2
Sigma<-  Matern( rdist(x,x)/aRange , smoothness=1.0)
Sigma.5<- chol( Sigma)
tau<- .1
#  250 independent spatial data sets but a common covariance function
#    -- there is little overhead in
#        MLE across independent realizations and a good test of code validity.
M<-250
F.true<- t( Sigma.5) %*% matrix( rnorm(N*M), N,M)
Y<-  F.true +  tau* matrix( rnorm(N*M), N,M)
par.grid<- list( aRange= seq( .1,.35,,8))
obj1b<- mKrigMLEGrid( x,Y,
cov.args = list(Covariance="Matern", smoothness=1.0),
cov.params.start=list( lambda = .5)
par.grid = par.grid
)
obj1b<- mKrigMLEGrid( x,Y,
cov.args = list(Covariance="Matern", smoothness=1.0),
cov.params.start=list( lambda = .5),
par.grid = par.grid
)
obj1b$summary # take a look
# profile over aRange
plot( par.grid$aRange, obj1b$summary[,"lnProfileLike.FULL"],
type="b", log="x")
# m=0 is a simple switch to indicate _no_ fixed spatial drift
# (the default and highly recommended  is linear drift, m=2).
# However, m=0 results in MLEs that are less biased, being the correct model
# -- in fact it nails it !
obj1a<- mKrigMLEJoint(x,Y,
cov.args=list(Covariance="Matern", smoothness=1.0),
cov.params.start=list(aRange =.5, lambda = .5),
mKrig.args= list( m=0))
test.for.zero( obj1a$summary["tau"], tau, tol=.007)
test.for.zero( obj1a$summary["aRange"], aRange, tol=.015)
data( ozone2)
obj<- spatialProcess( ozone2$lon.lat,ozone2$y[16,] )
######### boot strap
set.seed(123)
M<- 25
# create M indepedent copies of the observation vector
ySynthetic<- simSpatialData( obj, M)
bootSummary<- NULL
aRangeMLE<- obj$summary["aRange"]
lambdaMLE<- obj$summary["lambda"]
for(  k in 1:M){
cat( k, " " )
# here the MLEs are found using the easy top level level wrapper
# see mKrigMLEJoint for a more efficient strategy
out <- mKrigMLEJoint(obj$x, ySynthetic[,k],
weights = obj$weights,
mKrig.args = obj$mKrig.args,
cov.function = obj$cov.function.name,
cov.args = obj$cov.args,
cov.params.start = list( aRange = aRangeMLE,
lambda = lambdaMLE)
)
newSummary<- out$summary
bootSummary<- rbind( bootSummary, newSummary)
}
cat(  " ", fill=TRUE )
obj$summary
stats( bootSummary)
}
obj2<- mKrigMLEJoint(x,Y,
cov.args=list(Covariance="Matern"),
cov.params.start=list( aRange = .18,
smoothness = 1.1,
lambda = .08),
)
#look at lnLikelihood  evaluations
obj2$summary
#compare to REML
obj3<- mKrigMLEJoint(x,Y,
cov.args=list(Covariance="Matern"),
cov.params.start=list(aRange = .18,
smoothness = 1.1,
lambda = .08),
, REML=TRUE)
obj3$summary
obj4<- mKrigMLEJoint(x,Y,
mKrig.args= list( m=0),
cov.args=list(Covariance="Matern", smoothness=1),
cov.params.start=list(aRange=.2, lambda=.1),
REML=TRUE)
#look at lnLikelihood  evaluations
obj4$summary
library( fields)
predictSurface.default
help( Tps)
help( "in.poly")
library( fields)
setwd("~/Dropbox/Home/Repositories/fields/fields/man")
prompt( offGridWeights)
offGridWeights
interp.surface
data( "ozone2")
s<- ozone2$lon.lat
mKrigObject<- spatialProcess( s, ozone2$y[16,],
smoothness=.5)
# create a grid that has margins larger than the data
# locations
nx<- 128
ny<- 128
xr<- range( s)
yr<- range( s)
xr
yr
xr<- range( s[,1])
yr<- range( s[,2])
xr
yr
data( "ozone2")
s<- ozone2$lon.lat
mKrigObject<- spatialProcess( s, ozone2$y[16,],
smoothness=.5)
# create a grid that has margins larger than the data
# locations
nx<- 128
ny<- 128
# these are "hard coded" to work with these data and np=3
# see the function simNN.mKrig for computing a grid that
# is a superset of the locations
#
gridList<- list( x= seq(-93, -82,length.out=nx),
y= seq(36, 45,  length.out=ny ))
obj<- offGridWeights( s, gridList, np=3)
xr
gridList
xr
gridList<- list( x= seq(-94, -82,length.out=nx),
y= seq(36, 45,  length.out=ny ))
obj<- offGridWeights( s, gridList, np=3)
obj<- offGridWeights( s, gridList, np=3,
mKrigObject=fitObject )
data( "ozone2")
s<- ozone2$lon.lat
fitObject<- spatialProcess( s, ozone2$y[16,],
smoothness=.5)
# create a grid that has margins larger than the data
# locations
nx<- 128
ny<- 128
# these are "hard coded" to work with these data and np=3
# see the function simNN.mKrig for computing a grid that
# is a superset of the locations
#
gridList<- list( x= seq(-94, -82,length.out=nx),
y= seq(36, 45,  length.out=ny ))
obj<- offGridWeights( s, gridList, np=3,
mKrigObject=fitObject )
xGrid<- seq( -1, 1, length.out=128)
gridList<- list( x= xGrid,
y= xGrid
)
np<- 3
# sample 200 locations but avoid margins
set.seed(123)
s<- matrix( runif(xGrid[(np+1):(128-np), 200*2 ], 200, 2 ))
set.seed(123)
s<- matrix(    runif(200*2, xGrid[(np+1)],xGrid[(128-np)]),
200, 2 )
plot(s)
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .3, sigma2= 1.0,
cov.args= list( smoothness=1.0)
)
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .3, sigma2= 1.0,
covArgs= list( smoothness=1.0)
)
circulantEmbeddingSetup
CEobj<- CirculantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05
smoothness=1.0)
)
set.seed( 333)
y<- CirculantEmbedding(CEobj)
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05
smoothness=1.0)
)
set.seed( 333)
y<- circulantEmbedding(CEobj)
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .05, sigma2= 1.0,
covArgs= list( smoothness=1.0)
)
# try it out simulate a Matern field
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05,
smoothness=1.0)
)
set.seed( 333)
y<- circulantEmbedding(CEobj)
image.plot( y)
predOffGrid<- obj$B%*% c( y)
args( bubblePlot)
set.seed( 333)
y<- circulantEmbedding(CEobj)
predOffGrid<- obj$B\%*\% c( y)
bubblePlot( s, z= predOffGrid,  )
set.seed( 333)
y<- circulantEmbedding(CEobj)
predOffGrid<- obj$B\%*\% c( y)
bubblePlot( s[,1],s[,2], z= predOffGrid  )
# a grid
xGrid<- seq( -1, 1, length.out=128)
gridList<- list( x= xGrid,
y= xGrid
)
np<- 3
# sample 2000 locations but avoid margins
set.seed(123)
s<- matrix(    runif(2000*2, xGrid[(np+1)],xGrid[(128-np)]),
2000, 2 )
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .05, sigma2= 1.0,
covArgs= list( smoothness=1.0)
)
# try it out simulate a Matern field
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05,
smoothness=1.0)
)
set.seed( 333)
y<- circulantEmbedding(CEobj)
predOffGrid<- obj$B%*% c( y)
bubblePlot( s[,1],s[,2], z= predOffGrid  )
150^2
bubblePlot( s[,1],s[,2], z= predOffGrid , cex=.5 )
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.5 )
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75 )
set.panel( 1,2)
image.plot(gridList$x, gridList$y, Z)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75 )
set.seed( 333)
Z<- circulantEmbedding(CEobj)
predOffGrid<- obj$B%*% c( Z)
set.panel( 1,2)
image.plot(gridList$x, gridList$y, Z)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75 )
set.panel()
args( bubblePlot)
set.panel( 1,2)
image.plot(gridList$x, gridList$y, Z)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE)
set.panel()
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr
set.panel()
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr)
set.panel()
bubblePlot
color.scale
source('~/Dropbox/Home/Repositories/fields/fields/R/bubblePlot.R', echo=TRUE)
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr)
set.panel()
xGrid<- seq( -1, 1, length.out=200)
gridList<- list( x= xGrid,
y= xGrid
)
np<- 3
# sample 6000 locations but avoid margins
set.seed(123)
s<- matrix(    runif(6000*2, xGrid[(np+1)],xGrid[(128-np)]),
6000, 2 )
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .05, sigma2= 1.0,
covArgs= list( smoothness=1.0)
)
# try it out simulate a Matern field
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05,
smoothness=1.0)
)
set.seed( 333)
Z<- circulantEmbedding(CEobj)
predOffGrid<- obj$B%*% c( Z)
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr)
set.panel()
predOffGrid<- obj$B%*% c( Z)
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr)
set.panel()
xGrid<- seq( -1, 1, length.out=200)
gridList<- list( x= xGrid,
y= xGrid
)
np<- 3
# sample 6000 locations but avoid margins
set.seed(123)
s<- matrix(    runif(6000*2, xGrid[(np+1)],xGrid[(128-np)]),
6000, 2 )
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .05, sigma2= 1.0,
covArgs= list( smoothness=1.0)
)
# try it out simulate a Matern field
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05,
smoothness=1.0)
)
set.seed( 333)
Z<- circulantEmbedding(CEobj)
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .05,
smoothness=1.0)
)
set.seed( 333)
Z<- circulantEmbedding(CEobj)
predOffGrid<- obj$B%*% c( Z)
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr)
set.panel()
# a 200X200 grid
xGrid<- seq( -1, 1, length.out=200)
gridList<- list( x= xGrid,
y= xGrid
)
np<- 3
# sample 6000 locations but avoid margins
set.seed(123)
s<- matrix(    runif(6000*2, xGrid[(np+1)],xGrid[(200-np)]),
6000, 2 )
obj<- offGridWeights( s, gridList, np=3,
Covariance="Matern",
aRange = .1, sigma2= 1.0,
covArgs= list( smoothness=1.0)
)
# make the predictions  by obj$B%*%c(y)
# where y is the matrix of values on the grid
# try it out on a simulated  Matern field
CEobj<- circulantEmbeddingSetup( gridList,
cov.args=list(
Covariance="Matern",
aRange = .1,
smoothness=1.0)
)
set.seed( 333)
Z<- circulantEmbedding(CEobj)
predOffGrid<- obj$B%*% c( Z)
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.75,
highlight=FALSE, zlim=zr)
set.panel()
set.panel( 1,2)
zr<- range( c(Z))
image.plot(gridList$x, gridList$y, Z, zlim=zr)
bubblePlot( s[,1],s[,2], z= predOffGrid , size=.5,
highlight=FALSE, zlim=zr)
set.panel()
