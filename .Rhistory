# b=0 and w=1
X1<- 1/( 1+ exp( -(   5 * u)) )
X2<- 1/( 1+ exp( -( -3 + 10 * u)) )
g<- 1/( 1+ exp( -(-1 + 2* X1 - 1.5*X2 ) ) )
plot( u, g, col="grey", type="l", lwd=2)
title("extra hidden layer")
27/1.5
18*7.97
library(shiny); runApp('Dropbox/Home/Teaching/MoWater/nonLinear/bSplineModelsShiny.R')
runApp('Dropbox/Home/Teaching/MoWater/nonLinear/nonlinearModelsShiny.R')
library( fields)
ls(pos=2)
QTps()
QTps
spatialProcess
library( fields)
args( sreg)
obj<- 1:10
tmp<- get("obj")
tmp
obj
tmp<- get("obj")
tmp[1:5]
library( fields)
help( image.plot)
x<- 1:10
y<- 1:15
z<- outer( x,y,"+")
ibrary(lubridate)
x<- 1:10
y<- 201:210
dates<- seq(ymd("2020/06/01"), ymd("2020/06/10"), by="day")
library(lubridate)
dates<- seq(ymd("2020/06/01"), ymd("2020/06/10"), by="day")
z<-  1:10
julian(dates)
bubblePlot( x, y, z)
z<- julian( dates)
z
z<- as.numeric(julian( dates))
bubblePlot( x, y, z)
bubblePlot( x, y, z, axis.args=list( at=c(18416,18420),
labels=c("sep","oct")) )
bubblePlot( x, y, z, axis.args=list( at=c(min(z), max(z)),
labels=c("Bmin","Bmax")) )
date2<- seq( ymd("2020/06/01"), ymd("2021/02/11"), by="month")
date2
months( date2)
?months
dates<- seq(ymd("2020/06/01"), ymd("2021/02/11"), by="day")
length( dates)
x<- 1:256
y<- rnorm( 256)
dates<- seq(ymd("2020/06/01"), ymd("2021/02/11"), by="day")
date2<- seq( min( dates),max( dates) by="month")
labels<- month( date2, abbreviate=TRUE)
z<- as.numeric(julian( dates))
zLegend<- as.numeric(julian( date2))
bubblePlot( x, y, z, axis.args=list( at=zLegend,
labels=labels) )
zLegend
labels
labels<- month( date2, abbreviate=TRUE)
labels<- month( date2)
labels
date2<- seq( min( dates),max( dates) by="month")
labels<- months( date2, abbreviate = TRUE)
labels
z<- as.numeric(julian( dates))
zLegend<- as.numeric(julian( date2))
bubblePlot( x, y, z, axis.args=list( at=zLegend,
labels=labels) )
dev.off()
z<- as.numeric(julian( dates))
zLegend<- as.numeric(julian( date2))
bubblePlot( x, y, z, axis.args=list( at=zLegend,
labels=labels) )
library(lubridate)
x<- 1:256
y<- rnorm( 256)
dates<- seq(ymd("2020/06/01"), ymd("2021/02/11"), by="day")
date2<- seq( min( dates),max( dates) by="month")
labels<- months( date2, abbreviate = TRUE)
z<- as.numeric(julian( dates))
zLegend<- as.numeric(julian( date2))
colorTable<- viridis( 256 )
bubblePlot( x, y, z,  col= colorTable, axis.args=list( at=zLegend,
labels=labels) )
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2))
lines(1:3, rnorm(3), pch = 2, lty = 2, type="o")
legend(1,-1,c("group A", "group B"), pch = c(1,2), lty = c(1,2))
plot(1:3, rnorm(3), pch = 1, lty = 1, type = "o", ylim=c(-2,2), bty='L')
# this legend gets clipped:
legend(2.8,0,c("group A", "group B"), pch = c(1,2), lty = c(1,2))
# so turn off clipping:
par(xpd=TRUE)
legend(2.8,-1,c("group A", "group B"), pch = c(1,2), lty = c(1,2))
A <- data.frame(x=rnorm(100, 20, 2), y=rnorm(100, 20, 2))
B <- data.frame(x=rnorm(100, 21, 1), y=rnorm(100, 21, 1))
# Add extra space to right of plot area; change clipping to figure
par(mar=c(5.1, 4.1, 4.1, 8.1), xpd=TRUE)
# Plot both groups
plot(y ~ x, A, ylim=range(c(A$y, B$y)), xlim=range(c(A$x, B$x)), pch=1,
main="Scatter plot of two groups")
points(y ~ x, B, pch=3)
# Add legend to top right, outside plot region
legend("topright", inset=c(-0.2,0), legend=c("A","B"), pch=c(1,3), title="Group")
help( legend)
stationary.cov
library( fields)
stationary.cov
source('~/Dropbox/Home/Repositories/fields/offGridWeights.R', echo=TRUE)
library( fields)
sim.mKrig.approx
args( Exponential)
library( fields)
args( Exponential)
names( args( Exponential))
names( Exponential)
as.list( Exponential)
look<- as.list( Exponential)[-last]
look<- as.list( Exponential)
names( look[ -length( look)])
help( do.call)
predictSurface.mKrig
predictSurface.Krig
circulantEmbedding
source('~/Dropbox/Home/Repositories/fields/fields/R/sim.mKrig.NN.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/fields/R/sim.mKrig.NN.R', echo=TRUE)
library( fields)
help( "spatialProcess")
data( ozone2)
# x is a two column matrix where each row is a location in lon/lat
# coordinates
x<- ozone2$lon.lat
# y is a vector of ozone measurements at day 16. Note some missing values.
y<- ozone2$y[16,]
# artifically reduce size of data for a quick example to pass CRAN ...
x<- x[1:75,]
y<- y[1:75]
# lots of default choices  made here -- see gridN to increase
# the number of points in grid searches for MLEs
# without specifying  lambda or aRange both are found in a robust
# way uses grid searches
# profiling over lambda and aRange  is not reuqired but completes the full
# example.  Omit this for a faster computation.
obj<- spatialProcess( x, y, profileLambda=TRUE, profileARange=TRUE)
# summary of model
summary( obj)
set.panel(2,2)
plot(obj)
plot( obj, which=1)
plot( obj, which=2)
plot( obj, which=3)
plot( obj, which=4)
plot.spatialProcess(which=4)
plot.spatialProcess(obj, which=4)
source('~/Dropbox/Home/Repositories/fields/fields/R/plot.spatialProcess.R', echo=TRUE)
plot.spatialProcess(obj, which=4)
out<- obj
out$summary["tau"]
obj$summary
data( ozone2)
y<- ozone2$y[16,]
good<- !is.na( y)
y<-y[good]
x<- ozone2$lon.lat[good,]
# nearly interpolate using defaults (Exponential covariance range = 2.0)
# see also mKrigMLEGrid to choose lambda by maxmimum likelihood
out<- mKrig( x,y, aRange = 2.0, lambda=.01)
out$summary
source('~/Dropbox/Home/Repositories/fields/fields/R/mKrig.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/fields/R/mKrig.R', echo=TRUE)
data( ozone2)
y<- ozone2$y[16,]
good<- !is.na( y)
y<-y[good]
x<- ozone2$lon.lat[good,]
# nearly interpolate using defaults (Exponential covariance range = 2.0)
# see also mKrigMLEGrid to choose lambda by maxmimum likelihood
out<- mKrig( x,y, aRange = 2.0, lambda=.01)
out$summary
help( mKrigMLE)
library( fields)
help( mKrigMLE)
help( mKrigMLE)
help( mKrigMLEGrid)
help( mKrigMLEGrid)
help( mKrig)
library( fields)
help( "mKrigMLEGrid")
data(ozone2)
s<- ozone2$lon.lat
z<- ozone2$y[16,]
gridList<- list( aRange = seq( .4,1.0,length.out=20),
lambda = 10**seq( -1.5,0,length.out=20)
)
par.grid<- make.surface.grid( gridList)
out<- mKrigMLEGrid( s,z, par.grid=par.grid,
cov.args= list(smoothness=1.0,
Covariance="Matern" )
)
outP<- as.surface( par.grid, out$summary[,"lnProfileLike.FULL"])
image.plot( outP$x, log10(outP$y),outP$z,
xlab="aRange", ylab="log10 lambda")
data(ozone2)
s<- ozone2$lon.lat
z<- ozone2$y[16,]
gridList<- list( aRange = seq( .4,1.0,length.out=20),
lambda = 10**seq( -1.5,0,length.out=20)
)
par.grid<- make.surface.grid( gridList)
out<- mKrigMLEGrid( s,z, par.grid=par.grid,
cov.args= list(smoothness=1.0,
Covariance="Matern" )
)
outP<- as.surface( par.grid, out$summary[,"lnProfileLike.FULL"])
image.plot( outP$x, log10(outP$y),outP$z,
xlab="aRange", ylab="log10 lambda")
dev.off()
image.plot( outP$x, log10(outP$y),outP$z,
xlab="aRange", ylab="log10 lambda")
N<- 50
set.seed(123)
x<- matrix(runif(2*N), N,2)
aRange<- .2
Sigma<-  Matern( rdist(x,x)/aRange , smoothness=1.0)
Sigma.5<- chol( Sigma)
tau<- .1
#  250 independent spatial data sets but a common covariance function
#    -- there is little overhead in
#        MLE across independent realizations and a good test of code validity.
M<-250
F.true<- t( Sigma.5) %*% matrix( rnorm(N*M), N,M)
Y<-  F.true +  tau* matrix( rnorm(N*M), N,M)
# find MLE for lambda with grid of ranges
# and smoothness fixed in Matern
par.grid<- list( aRange= seq( .1,.35,,8))
obj1b<- mKrigMLEGrid( x,Y,
cov.args = list(Covariance="Matern", smoothness=1.0),
par.grid = par.grid
)
obj1b$summary # take a look
# profile over aRange
plot( par.grid$aRange, obj1b$summary[,"lnProfileLike.FULL"],
type="b", log="x")
N<- 50
set.seed(123)
x<- matrix(runif(2*N), N,2)
aRange<- .2
Sigma<-  Matern( rdist(x,x)/aRange , smoothness=1.0)
Sigma.5<- chol( Sigma)
tau<- .1
#  250 independent spatial data sets but a common covariance function
#    -- there is little overhead in
#        MLE across independent realizations and a good test of code validity.
M<-250
F.true<- t( Sigma.5) %*% matrix( rnorm(N*M), N,M)
Y<-  F.true +  tau* matrix( rnorm(N*M), N,M)
par.grid<- list( aRange= seq( .1,.35,,8))
obj1b<- mKrigMLEGrid( x,Y,
cov.args = list(Covariance="Matern", smoothness=1.0),
cov.params.start=list( lambda = .5)
par.grid = par.grid
)
obj1b<- mKrigMLEGrid( x,Y,
cov.args = list(Covariance="Matern", smoothness=1.0),
cov.params.start=list( lambda = .5),
par.grid = par.grid
)
obj1b$summary # take a look
# profile over aRange
plot( par.grid$aRange, obj1b$summary[,"lnProfileLike.FULL"],
type="b", log="x")
# m=0 is a simple switch to indicate _no_ fixed spatial drift
# (the default and highly recommended  is linear drift, m=2).
# However, m=0 results in MLEs that are less biased, being the correct model
# -- in fact it nails it !
obj1a<- mKrigMLEJoint(x,Y,
cov.args=list(Covariance="Matern", smoothness=1.0),
cov.params.start=list(aRange =.5, lambda = .5),
mKrig.args= list( m=0))
test.for.zero( obj1a$summary["tau"], tau, tol=.007)
test.for.zero( obj1a$summary["aRange"], aRange, tol=.015)
data( ozone2)
obj<- spatialProcess( ozone2$lon.lat,ozone2$y[16,] )
######### boot strap
set.seed(123)
M<- 25
# create M indepedent copies of the observation vector
ySynthetic<- simSpatialData( obj, M)
bootSummary<- NULL
aRangeMLE<- obj$summary["aRange"]
lambdaMLE<- obj$summary["lambda"]
for(  k in 1:M){
cat( k, " " )
# here the MLEs are found using the easy top level level wrapper
# see mKrigMLEJoint for a more efficient strategy
out <- mKrigMLEJoint(obj$x, ySynthetic[,k],
weights = obj$weights,
mKrig.args = obj$mKrig.args,
cov.function = obj$cov.function.name,
cov.args = obj$cov.args,
cov.params.start = list( aRange = aRangeMLE,
lambda = lambdaMLE)
)
newSummary<- out$summary
bootSummary<- rbind( bootSummary, newSummary)
}
cat(  " ", fill=TRUE )
obj$summary
stats( bootSummary)
}
obj2<- mKrigMLEJoint(x,Y,
cov.args=list(Covariance="Matern"),
cov.params.start=list( aRange = .18,
smoothness = 1.1,
lambda = .08),
)
#look at lnLikelihood  evaluations
obj2$summary
#compare to REML
obj3<- mKrigMLEJoint(x,Y,
cov.args=list(Covariance="Matern"),
cov.params.start=list(aRange = .18,
smoothness = 1.1,
lambda = .08),
, REML=TRUE)
obj3$summary
obj4<- mKrigMLEJoint(x,Y,
mKrig.args= list( m=0),
cov.args=list(Covariance="Matern", smoothness=1),
cov.params.start=list(aRange=.2, lambda=.1),
REML=TRUE)
#look at lnLikelihood  evaluations
obj4$summary
setwd("~/Dropbox/Home/Repositories/fields")
rm(list=ls())
library(fields)
source("timeOffGrid.R")
# -----------------------------
# Define grid and observations
# -----------------------------
np<- 4
out<- NULL
for(  m in c( 128, 256, 512, 1024, 2048)){
for( M in c( 100, 400, 1600,  6400, 12800)){
for( k in 1:10){
tmp<- timeOffGrid(m,M,np)
out<- rbind( out, tmp)
}
}
}
table1<- tapply(out[,3], list( out[,1], out[,2]), mean )
library( xtable)
xtable( table1)
table1<- tapply(out[,3], list( out[,1], out[,2]), mean )
table2<- tapply(out[,4], list( out[,1], out[,2]), mean )
help( xtable)
print( xtable( table1,file="timingTable1.tex" ))
dir()
print( xtable( table1),file="timingTable1.tex" )
dir()
table1
print( xtable( round(table1,3),file="timingTable1.tex" ))
np<- 4
out<- NULL
for(  m in c( 128,  512,  2048)){
for( M in c( 400,  1600, 6400)){
for( k in 1:20){
tmp<- timeOffGrid(m,M,np)
out<- rbind( out, tmp)
}
}
}
table1<- tapply(out[,3], list( out[,1], out[,2]), mean )
table2<- tapply(out[,4], list( out[,1], out[,2]), mean )
print( xtable( round(table1,3),file="timingTable1.tex" ))
print( xtable( table2),file="timingTable1.tex" )
print( xtable( round(table2,4), file="timingTable1.tex" ))
print( xtable( round(table1,3)),file="timingTable1.tex" )
print( xtable( round(table2,4)), file="timingTable1.tex" )
cbind( table1, table2)
print( xtable( round(cbind(table1,table2),3)), file="timingTable3np4.tex" )
xtable( round(cbind(table1,table2),3))
np<- 2
out<- NULL
for(  m in c( 128,  512,  2048)){
for( M in c( 400,  1600, 6400)){
for( k in 1:20){
tmp<- timeOffGrid(m,M,np)
out<- rbind( out, tmp)
}
}
table1<- tapply(out[,3], list( out[,1], out[,2]), mean )
table2<- tapply(out[,4], list( out[,1], out[,2]), mean )
print( xtable( round(cbind(table1,table2),3)), file="timingTable3np2.tex" )
source('~/Dropbox/Home/Repositories/fields/figOffGridTiming.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/figOffGridTiming.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
look<- timeCEWithNN( 64, 10, 4)
look
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
look<- timeCEWithNN( 64, 100, 10, 4)
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
look<- timeCEWithNN( 64, 100, 10, 4)
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
look<- timeCEWithNN( 64, 100, 10, 4)
looo
look
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
look<- timeCEWithNN( 64, 100, 10, 4)
look
look
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
look<- timeCEWithNN( 64, 100, 10, 4)
look
look<- timeCEWithNN( 128, 1000, 10, 4)
look
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
look<- timeCEWithNN( 128, 1000, 10, 4)
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
look<- timeCEWithNN( 128, 1000, 10, 4)
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
look<- timeCEWithNN( 128, 1000, 10, 4)
look
np<- 2
out<- NULL
for(  m in c( 128,  512 )){
for( n in c( 400,  1600, 6400)){
tmp<- timeCEWithNN( m, n, 1, 4)
print( c( m,n,tmp))
out<- rbind( out, c( m,n,tmp) )
}
}
stationary.cov
np<- 2
out<- NULL
for(  m in c( 128,  512 )){
for( n in c( 400,  1600, 6400)){
tmp<- timeCEWithNN( m, n, 1, 4)
print( c( m,n,tmp))
out<- rbind( out, c( m,n,tmp) )
}
}
c
Exp.cov
n<- 1600
s<- matrix( runif(n*2 ),n,2)
y<-  rnorm( n)
t1<- system.time(
mKrigObject<- spatialProcess( s,y,cov.function=Exp.cov,
Range=.1, lambda=.1
)
)
mKrigObject<- mKrig( s,y,cov.function=Exp.cov,
cov.args= list(aRange=.1),
lambda=.1
)
m<- 128
M
t2<- system.time(
look<- simLocal.mKrig(mKrigObject, M=1,nx=m, ny=m,
gridRefinement = 1, np=np, giveWarnings=FALSE)
)
t2
m<- 512
t2<- system.time(
look<- simLocal.mKrig(mKrigObject, M=1,nx=m, ny=m,
gridRefinement = 1, np=np, giveWarnings=FALSE)
)
t2
n<-128
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
np<- 2
out<- NULL
for(  m in c( 128,  512 )){
for( n in c( 400,  1600)){
tmp<- timeCEWithNN( m, n, 1, 4)
print( c( m,n,tmp))
out<- rbind( out, c( m,n,tmp) )
}
}
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
timeCEWithNN(128, 1000, 1, 4)
library(tictoc)
timeCEWithNN(128, 1000, 1, 4)
timeCEWithNN(512, 1000, 1, 4)
source('~/Dropbox/Home/Repositories/fields/timeCEWithN.R', echo=TRUE)
timeCEWithNN(512, 1000, 1, 4)
timeCEWithNN(512, 1000, 5, 4)
hold<- timeCEWithNN(256, 1000, 5, 4)
hold<- timeCEWithNN(256, 500, 5, 4)
hold
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
hold<- timeCEWithNN(256, 500, 5, 4)
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
hold<- timeCEWithNN(256, 500, 5, 4)
hold<- timeCEWithNN(256, 500, 20, 4)
hold<- timeCEWithNN(512, 500, 1, 4)
hold
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
hold<- timeCEWithNN(512, 500, 1, 4)
help( system.time)
unlist( hold)
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
hold<- timeCEWithNN(256, 500, 5, 4)
hold
source('~/Dropbox/Home/Repositories/fields/fields/R/simLocal.mKrig.R', echo=TRUE)
hold<- timeCEWithNN(256, 400, 10, 4)
